name: Build & Share AppStream Rocky Linux Image

on:
  workflow_dispatch:
    inputs:
      builder_name:
        description: 'Unique name for the Image Builder instance'
        required: true
        type: string
      image_name:
        description: 'Desired AppStream Output image name'
        required: true
        type: string
  
  pull_request:
    branches:
      - main
    types:
      - opened
      - synchronize

  push:
    branches:
      - main

permissions:
  contents: read
  id-token: write
  actions: read

env:
  AWS_REGION: eu-west-2

jobs:
  infra:
    name: Provision infra with Terragrunt
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
      
      - name: Install yq binary
        run: |
            curl -L \
            https://github.com/mikefarah/yq/releases/download/v4.30.8/yq_linux_amd64 \
            -o /usr/local/bin/yq
            chmod +x /usr/local/bin/yq
            yq --version

      - name: Load config.yaml into env vars
        shell: bash
        run: |
            echo "PROJECT_NAME=$(yq e '.config.project_name' config.yaml)"            >> $GITHUB_ENV
            echo "BASE_IMAGE_NAME=$(yq e '.config.base_image_name' config.yaml)"      >> $GITHUB_ENV
            echo "LIVE_ACCOUNT_ID=$(yq e '.config.live_account_id' config.yaml)"      >> $GITHUB_ENV
            echo "PRELIVE_ACCOUNT_ID=$(yq e '.config.prelive_account_id' config.yaml)" >> $GITHUB_ENV
            echo "DOC_SOURCE=$(yq e '.config.doc_source' config.yaml)"                >> $GITHUB_ENV
            echo "VPC_ID=$(yq e '.config.vpc_id' config.yaml)"                        >> $GITHUB_ENV
            echo "SUBNET_ID=$(yq e '.config.subnet_id' config.yaml)"                  >> $GITHUB_ENV
            echo "SECURITY_GROUP_ID=$(yq e '.config.security_group_id' config.yaml)"  >> $GITHUB_ENV
            echo "ACCOUNT_ID=$(yq e '.config.accounts.account_id' config.yaml)"        >> $GITHUB_ENV
    
      - name: Assume Terragrunt Plan Role
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ env.ACCOUNT_ID }}:role/cc-appstream2-terragrunt-apply-role
          aws-region: eu-west-2

      - name: Find and remove .terragrunt-cache directories
        run: |
          echo "Finding and removing all .terragrunt-cache directories in the working directory..."
          sudo find $GITHUB_WORKSPACE -type d -name '.terragrunt-cache' -exec rm -rf {} +
          echo "Completed removal of .terragrunt-cache directories."

      - name: Terragrunt Plan
        uses: gruntwork-io/terragrunt-action@v2
        with:
          tf_version: 1.9.3
          tg_version: 0.59.6
          tg_dir: ./ccpamappstream/
          tg_command: run-all plan
        timeout-minutes: 20

      - name: Terragrunt Apply
        uses: gruntwork-io/terragrunt-action@v2
        with:
          tf_version: 1.9.3
          tg_version: 0.59.6
          tg_dir: ./ccpamappstream/
          tg_command: run-all apply -auto-approve
        timeout-minutes: 20

  build:
    name: Trigger Step Function & Wait
    needs: infra
    if: github.ref == 'refs/heads/main' && success()
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Install yq binary
        run: |
            curl -L \
            https://github.com/mikefarah/yq/releases/download/v4.30.8/yq_linux_amd64 \
            -o /usr/local/bin/yq
            chmod +x /usr/local/bin/yq
            yq --version

      - name: Set environment variables
        shell: bash
        run: |
          echo "ACCOUNT_ID=$(yq e '.config.accounts.account_id' config.yaml)" >> $GITHUB_ENV

      - name: Configure AWS credentials with role to assume
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ env.ACCOUNT_ID }}:role/cc-appstream2-terragrunt-apply-role
          aws-region: eu-west-2

      - name: Install Terragrunt & Terraform
        uses: gruntwork-io/terragrunt-action@v2
        env:
           INPUT_PRE_EXEC_0: |
             curl -sSL "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o /tmp/awscliv2.zip && \
             unzip -q /tmp/awscliv2.zip -d /tmp && \
             /tmp/aws/install --update && \
             rm -rf /tmp/aws /tmp/awscliv2.zip
        with:
          tf_version: 1.9.3
          tg_version: 0.59.6
          tg_dir: ./ccpamappstream/
          tg_command:  --help # we only need the install, so use a no-op command
        timeout-minutes: 10

      - name: Get State Machine ARN
        working-directory: ./ccpamappstream
        run: |
          SM_ARN=$(terragrunt output --raw state_machine_arn)
          echo "SM_ARN=$SM_ARN" >> $GITHUB_ENV
          echo "Resolved State Machine ARN: $SM_ARN"

      - name: Start Step Function Execution
        id: start
        run: |
          PAYLOAD=$(jq -n \
            --arg builder "${{ github.event.inputs.builder_name }}" \
            --arg baseImage "${{ github.event.inputs.image_name }}" \
            --arg subnet "${{ env.SUBNET_ID }}" \
            --arg sg "${{ env.SECURITY_GROUP_ID }}" \
            --arg liveAcct "${{ env.LIVE_ACCOUNT_ID }}" \
            --arg preliveAcct "${{ env.PRELIVE_ACCOUNT_ID }}" \
            '{
              BuilderName:        $builder,
              BaseImageName:      $baseImage,
              SubnetIds:          [$subnet],
              SecurityGroupIds:   [$sg],
              live_account_id:    $liveAcct,
              prelive_account_id: $preliveAcct
            }')

          echo "Payload: $PAYLOAD"
          EXEC_ARN=$(aws stepfunctions start-execution \
            --state-machine-arn "${{ env.SM_ARN }}" \
            --input "$PAYLOAD" \
            --query executionArn --output text)

          echo "EXEC_ARN=$EXEC_ARN" >> $GITHUB_OUTPUT
          echo "Started execution: $EXEC_ARN"
        
      - name: Wait for Step Function Completion
        shell: bash
        run: |
          set -euo pipefail

          EXECUTION_ARN="${{ steps.start.outputs.EXEC_ARN }}"

          echo "Waiting for Step Function to succeed (ARN: $EXECUTION_ARN)..."

          if ! aws stepfunctions wait execution-succeeded --execution-arn "$EXECUTION_ARN"; then
            echo "::error ::Step Function waiter failed‚Äîfetching execution details for debugging:"
            aws stepfunctions describe-execution \
              --execution-arn "$EXECUTION_ARN" \
              --query '{Status:status,Error:stateMachineError,Cause:stateMachineCause,Output:output}' \
              --output json
            exit 1
          fi

          echo "‚úÖ Step Function execution succeeded!"
        
      - name: Check Final AppStream Image Status
        shell: bash
        run: |
            set -euo pipefail

            IMAGE_NAME="${{ github.event.inputs.image_name }}"
            echo "üîç Checking status for AppStream image: $IMAGE_NAME"

            # Try to fetch the state, or fallback to NOT_FOUND
            IMAGE_STATE=$(aws appstream describe-images \
            --names "$IMAGE_NAME" \
            --query 'Images[0].State' \
            --output text 2>/dev/null || echo "NOT_FOUND")

            echo "Image Status: $IMAGE_STATE"

            if [[ "$IMAGE_STATE" == "AVAILABLE" ]]; then
            echo "‚úÖ Image is AVAILABLE and ready for use!"
            echo ""
            echo "‚ÑπÔ∏è  Image Details:"
            aws appstream describe-images \
                --names "$IMAGE_NAME" \
                --query 'Images[0].{Name:Name,State:State,CreatedTime:CreatedTime,Description:Description}' \
                --output table
            else
            echo "‚ö†Ô∏è  Image is not yet available. Current status: $IMAGE_STATE"
            if [[ "$IMAGE_STATE" == "NOT_FOUND" ]]; then
                echo "   It looks like the image doesn‚Äôt exist‚Äîdid the build step succeed?"
            fi
            exit 1
            fi

      - name: Verify Image Sharing
        shell: bash
        run: |
          set -euo pipefail
          IMAGE_NAME="${{ github.event.inputs.image_name }}"

          echo "üîç Verifying image sharing with target accounts..."
          if ! aws appstream describe-image-permissions \
               --image-name "$IMAGE_NAME" \
               --query 'Principals[?Permissions[?FleetCreation==`true`]].AccountID' \
               --output table; then
            echo "‚ö†Ô∏è  Unable to retrieve sharing permissions or none set."
          fi

          echo ""
          echo "Image '$IMAGE_NAME' should be shared with:"
          echo "- Live Account:    ${{ env.LIVE_ACCOUNT_ID }}"
          echo "- Pre-live Account: ${{ env.PRELIVE_ACCOUNT_ID }}"  

      - name: Cleanup Summary
        shell: bash
        run: |
          set -euo pipefail
          echo "üéâ AppStream Image Builder Automation Summary"
          echo "=============================================="
          echo "Builder Name: ${{ github.event.inputs.builder_name }}"
          echo "Image Name:   ${{ github.event.inputs.image_name }}"
          echo "Region:       ${{ env.AWS_REGION }}"
          echo "Execution ARN: ${{ steps.start.outputs.EXEC_ARN }}"
          echo ""
          echo "‚úÖ Infrastructure provisioned"
          echo "‚úÖ Image builder created and configured"
          echo "‚úÖ Packages installed via SSM"
          echo "‚úÖ AppStream image created"
          echo "‚úÖ Image shared with target accounts"
          echo "‚úÖ Image builder cleaned up"
          echo ""
          echo "Your new AppStream image is ready for use!"